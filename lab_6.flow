import string;
import lingo/pegcode/driver;

Expr ::= IntConst, Mul, Add;
IntConst: (value: int);
Mul: (left: Expr, right: Expr);
Add: (left: Expr, right: Expr);

ExprRPN ::= IntConstRPN, MulRPN, AddRPN;
IntConstRPN: (value: int);
MulRPN: ();
AddRPN: ();

expr2str(expr: Expr) -> string {
    switch (expr : Expr) {         
        IntConst(c): i2s(c);
        Mul(l, r): "(" + expr2str(l) + "*" + expr2str(r) + ")";
        Add(l, r): "(" + expr2str(l) + "+" + expr2str(r) + ")";
    }
}

str2expr(str: string) -> Expr {
    lng = "#include D:\flow9\sandbox\mtk\lab_5.lingo";
    parsic(compilePegGrammar(lng), str, defaultPegActions);
}

Calc(expr: Expr) -> int {
    switch (expr : Expr) {         
        IntConst(c): c;
        Mul(l, r): Calc(l) * Calc(r);
        Add(l, r): Calc(l) + Calc(r);
    }
}

expr2rpn(expr: Expr) -> [ExprRPN] {
    switch (expr) {        
        IntConst(c): [IntConstRPN(c)];
        Mul(l, r): concat( concat( expr2rpn(l), expr2rpn(r) ), [MulRPN()] );
        Add(l, r): concat( concat( expr2rpn(l), expr2rpn(r) ), [AddRPN()] );
    }
}

rpn2str(exprRPN: [ExprRPN]) -> string {
    fold(exprRPN, "", \acc, e -> {
        switch (e) {
            IntConstRPN(c): acc + i2s(c) + " ";
            MulRPN(): acc + "* ";
            AddRPN(): acc + "+ ";
        }
    })
}

/*rpn2expr(exprRPN: [ExprRPN], i: int) -> Maybe<Expr> {
    if ( (i < 0) && (i >= length(exprRPN)) ) {
        None();        
    } else {
        switch(exprRPN[i]) {
            IntConstRPN(c): Some(IntConst(c));
            MulRPN(): {
                //???
            }
            AddRPN(): {
                //???
            }
        }
    }
}*/

main() {
    expr = Mul(Add(IntConst(4), Mul(IntConst(2), IntConst(3))), IntConst(5)); // (4 + 2 * 3) * 5 = 50
    println(expr);

    rpn = expr2rpn(expr);
    println(rpn);

    rpn_str = rpn2str(rpn);
    println(rpn_str);

    //rpn_expr = rpn2expr(rpn, 0);
    //println(prn_expr);

    quit(0);
}